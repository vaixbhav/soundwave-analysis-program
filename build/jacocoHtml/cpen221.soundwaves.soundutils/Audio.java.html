<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Audio.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mp1b-anisidvai</a> &gt; <a href="index.source.html" class="el_package">cpen221.soundwaves.soundutils</a> &gt; <span class="el_source">Audio.java</span></div><h1>Audio.java</h1><pre class="source lang-java linenums">package cpen221.soundwaves.soundutils;

import javax.sound.sampled.Clip;

import java.io.File;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.IOException;

import java.net.URL;

import java.util.LinkedList;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import javax.sound.sampled.UnsupportedAudioFileException;

/**
 *  &lt;p&gt;&lt;b&gt;Overview.&lt;/b&gt;
 *  The {@code Audio} class provides a basic capability for
 *  playing, reading, and saving audio.
 *  It uses a simple audio model that allows you
 *  to send one sample to the sound card at a time.
 *  Each sample is a real number between â€“1.0 and +1.0.
 *  The samples are played in real time using a sampling
 *  rate of 44,100 Hz.
 *  In addition to playing individual samples, standard audio supports
 *  reading, writing, and playing audio files in a variety of standard formats.
 *  &lt;p&gt;

 *  &lt;b&gt;Playing audio samples.&lt;/b&gt;
 *  You can use the following two methods to play individual audio samples:
 *  &lt;ul&gt;
 *  &lt;li&gt; {@link #play(double sample)}
 *  &lt;li&gt; {@link #play(double[] samples)}
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *  Each method sends the specified sample (or samples) to the sound card.
 *  The individual samples are real numbers between â€“1.0 and +1.0. If a
 *  sample is outside this range, it will be &lt;em&gt;clipped&lt;/em&gt; (rounded to
 *  â€“1.0 or +1.0). The samples are played in real time using a sampling
 *  rate of 44,100 Hz.
 *
 *  &lt;p&gt;
 *  &lt;b&gt;Playing audio files.&lt;/b&gt;
 *  You can use the following method to play an audio file:
 *  &lt;ul&gt;
 *  &lt;li&gt; {@link #play(String filename)}
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *  It plays an audio file (in WAVE, AU, AIFF, or MIDI format) and does
 *  not return until the audio file is finished playing. This can produce
 *  particularly striking programs with minimal code.
 *  For example, the following code fragment plays a drum loop:
 *
 *  &lt;pre&gt;
 *   while (true) {
 *       Audio.play(&quot;samples/BassDrum.wav&quot;);
 *       Audio.play(&quot;samples/SnareDrum.wav&quot;);
 *   }
 *  &lt;/pre&gt;
 *  &lt;p&gt;
 *
 *  &lt;b&gt;Reading and writing audio files.&lt;/b&gt;
 *  You can read and write audio files using the following two methods:
 *  &lt;ul&gt;
 *  &lt;li&gt; {@link #read(String filename)}
 *  &lt;li&gt; {@link #save(String filename, double[] samples)}
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *  The first method reads audio samples from an audio file
 *  (in WAVE, AU, AIFF, or MIDI format)
 *  and returns them as a double array with values between â€“1.0 and +1.0.
 *  The second method saves the samples in the specified double array to an
 *  audio file (in WAVE, AU, or AIFF format).
 *
 *  &lt;p&gt;
 *  &lt;b&gt;Audio file formats.&lt;/b&gt;
 *  {@code Audio} relies on the
 *  &lt;a href = &quot;https://www.oracle.com/java/technologies/javase/jmf-211-formats.html&quot;&gt;Java Media Framework&lt;/a&gt;
 *  for reading, writing, and playing  audio files. You should be able to read or play files
 *  in WAVE, AU, AIFF, and MIDI formats and save them to WAVE, AU, and AIFF formats.
 *  The file extensions corresponding to WAVE, AU, AIFF, and MIDI files
 *  are {@code .wav}, {@code .au}, {@code .aiff}, and {@code .midi},
 *  respectively.
 *  Some systems support additional audio file formats, but probably not MP3 or M4A.
 *  &lt;p&gt;
 *  The Java Media Framework supports a variety of different &lt;em&gt;audio data formats&lt;/em&gt;,
 *  which includes
 *  &lt;ul&gt;
 *  &lt;Li&gt; the sampling rate (e.g., 44,100 Hz);
 *  &lt;li&gt; the number of bits per sample per channel (e.g., 8-bit or 16-bit);
 *  &lt;li&gt; the number of channels (e.g., monaural or stereo);
 *  &lt;li&gt; the byte ordering (e.g., little endian or big endian); and
 *  &lt;li&gt; the encoding scheme (typically linear PCM).
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *  When saving files, {@code Audio} uses a sampling rate of 44,100 Hz,
 *  16 bits per sample, monaural audio, little endian, and linear PCM encoding.
 *
 *  &lt;p&gt;
 *  &lt;b&gt;Recording audio.&lt;/b&gt;
 *  You can use the following methods to record audio samples that are
 *  played as a result of calls to {@link #play(double sample)} or
 *  {@link #play(double[] samples)}.
 *  &lt;ul&gt;
 *  &lt;li&gt; {@link #startRecording()}
 *  &lt;li&gt; {@link #stopRecording()}
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *  The method {@link #startRecording()} begins recording audio.
 *  The method {@link #stopRecording()} stops recording and returns the recorded
 *  samples as an array of doubles.
 *  &lt;p&gt;
 *  {@code Audio} does not currently support recording audio that calls
 *  either {@link #play(String filename)} or
 *  {@link #playInBackground(String filename)}, as these may use different
 *  data formats, such as 8-bit and stereo.
 *  &lt;p&gt;
 *  &lt;b&gt;Playing audio files in a background thread.&lt;/b&gt;
 *  You can use the following methods to play an audio file in a background thread
 *  (e.g., as a background score in your program).
 *  &lt;ul&gt;
 *  &lt;li&gt; {@link #playInBackground(String filename)}
 *  &lt;li&gt; {@link #stopInBackground()}
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *  Each call to the first method plays the specified sound in a separate background
 *  thread. Unlike with the {@code play()} methods, your program will not wait
 *  for the samples to finish playing before continuing.
 *  It supports playing an audio file in WAVE, AU, AIFF, or MIDI format.
 *  It is possible to play
 *  multiple audio files simultaneously (in separate background threads).
 *  The second method stops the playing of all audio in background threads.
 *  &lt;p&gt;
 *  &lt;b&gt;Draining standard audio.&lt;/b&gt;
 *  On some systems, your Java program may terminate before all of the samples have been
 *  sent to the sound card. To prevent this, it is recommend that you call the
 *  following method to indicate that you are done using standard audio:
 *  &lt;ul&gt;
 *  &lt;li&gt; {@link #drain()}
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *  The method drains any samples queued to the sound card that have not yet been
 *  sent to the sound card.
 *  &lt;p&gt;
 *
 *  @author Sathish Gopalakrishnan
 */
public final class Audio {

    /**
     *  The sample rate: 44,100 Hz for CD quality audio.
     */
    public static final int SAMPLE_RATE = 44100;

    private static final int BYTES_PER_SAMPLE = 2;       // 16-bit audio
    private static final int BITS_PER_SAMPLE = 16;       // 16-bit audio
    private static final int MAX_16_BIT = 32768;
    private static final int SAMPLE_BUFFER_SIZE = 4096;

    private static final int MONO   = 1;
    private static final int STEREO = 2;
    private static final boolean LITTLE_ENDIAN = false;
    private static final boolean BIG_ENDIAN    = true;
    private static final boolean SIGNED        = true;
    private static final boolean UNSIGNED      = false;


    private static SourceDataLine line;   // to play the sound
    private static byte[] buffer;         // our internal buffer
<span class="nc" id="L177">    private static int bufferSize = 0;    // number of samples currently in internal buffer</span>

    // queue of background Runnable objects
<span class="nc" id="L180">    private static LinkedList&lt;BackgroundRunnable&gt; backgroundRunnables = new LinkedList&lt;&gt;();</span>

    // for recording audio
<span class="nc" id="L183">    private static QueueOfDoubles recordedSamples = null;</span>
<span class="nc" id="L184">    private static boolean isRecording = false;</span>

    private Audio() {
        // can not instantiate
    }

    // static initializer
    static {
<span class="nc" id="L192">        init();</span>
<span class="nc" id="L193">    }</span>

    // open up an audio stream
    private static void init() {
        try {
            // 44,100 Hz, 16-bit audio, mono, signed PCM, little endian
<span class="nc" id="L199">            AudioFormat format = new AudioFormat((float) SAMPLE_RATE, BITS_PER_SAMPLE, MONO, SIGNED, LITTLE_ENDIAN);</span>
<span class="nc" id="L200">            DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);</span>

<span class="nc" id="L202">            line = (SourceDataLine) AudioSystem.getLine(info);</span>
<span class="nc" id="L203">            line.open(format, SAMPLE_BUFFER_SIZE * BYTES_PER_SAMPLE);</span>

            // the internal buffer is a fraction of the actual buffer size, this choice is arbitrary
            // it gets divided because we can't expect the buffered data to line up exactly with when
            // the sound card decides to push out its samples.
<span class="nc" id="L208">            buffer = new byte[SAMPLE_BUFFER_SIZE * BYTES_PER_SAMPLE/3];</span>
        }
<span class="nc" id="L210">        catch (LineUnavailableException e) {</span>
<span class="nc" id="L211">            System.out.println(e.getMessage());</span>
<span class="nc" id="L212">        }</span>

        // no sound gets made before this call
<span class="nc" id="L215">        line.start();</span>
<span class="nc" id="L216">    }</span>

    // get an AudioInputStream object from a file
    private static AudioInputStream getAudioInputStreamFromFile(String filename) {
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (filename == null) {</span>
<span class="nc" id="L221">            throw new IllegalArgumentException(&quot;filename is null&quot;);</span>
        }

        try {
            // first try to read file from local file system
<span class="nc" id="L226">            File file = new File(filename);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (file.exists()) {</span>
<span class="nc" id="L228">                return AudioSystem.getAudioInputStream(file);</span>
            }

            // resource relative to .class file
<span class="nc" id="L232">            InputStream is1 = Audio.class.getResourceAsStream(filename);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (is1 != null) {</span>
<span class="nc" id="L234">                return AudioSystem.getAudioInputStream(is1);</span>
            }

            // resource relative to classloader root
<span class="nc" id="L238">            InputStream is2 = Audio.class.getClassLoader().getResourceAsStream(filename);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (is2 != null) {</span>
<span class="nc" id="L240">                return AudioSystem.getAudioInputStream(is2);</span>
            }

            // from URL (including jar file)
<span class="nc" id="L244">            URL url = new URL(filename);</span>
<span class="nc" id="L245">            return AudioSystem.getAudioInputStream(url);</span>
        }
<span class="nc" id="L247">        catch (IOException e) {</span>
<span class="nc" id="L248">            throw new IllegalArgumentException(&quot;could not read '&quot; + filename + &quot;'&quot;, e);</span>
        }
<span class="nc" id="L250">        catch (UnsupportedAudioFileException e) {</span>
<span class="nc" id="L251">            throw new IllegalArgumentException(&quot;file of unsupported audio file format: '&quot; + filename + &quot;'&quot;, e);</span>
        }
    }

    /**
     * Sends any queued samples to the sound card.
     */
    public static void drain() {
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (bufferSize &gt; 0) {</span>
<span class="nc" id="L260">            line.write(buffer, 0, bufferSize);</span>
<span class="nc" id="L261">            bufferSize = 0;</span>
        }
<span class="nc" id="L263">        line.drain();</span>
<span class="nc" id="L264">    }</span>


    /**
     * Closes standard audio.
     */
/*
    public static void close() {
        drain();
        line.stop();
    }
*/
    /**
     * Writes one sample (between â€“1.0 and +1.0) to standard audio.
     * If the sample is outside the range, it will be clipped
     * (rounded to â€“1.0 or +1.0).
     *
     * @param  sample the sample to play
     * @throws IllegalArgumentException if the sample is {@code Double.NaN}
     */
    public static void play(double sample) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (Double.isNaN(sample)) throw new IllegalArgumentException(&quot;sample is NaN&quot;);</span>

        // clip if outside [-1, +1]
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (sample &lt; -1.0) sample = -1.0;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (sample &gt; +1.0) sample = +1.0;</span>

        // save sample if recording
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (isRecording) {</span>
<span class="nc" id="L293">            recordedSamples.enqueue(sample);</span>
        }

        // convert to bytes
<span class="nc" id="L297">        short s = (short) (MAX_16_BIT * sample);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (sample == 1.0) s = Short.MAX_VALUE;   // special case since 32768 not a short</span>
<span class="nc" id="L299">        buffer[bufferSize++] = (byte) s;</span>
<span class="nc" id="L300">        buffer[bufferSize++] = (byte) (s &gt;&gt; 8);   // little endian</span>

        // send to sound card if buffer is full
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (bufferSize &gt;= buffer.length) {</span>
<span class="nc" id="L304">            line.write(buffer, 0, buffer.length);</span>
<span class="nc" id="L305">            bufferSize = 0;</span>
        }
<span class="nc" id="L307">    }</span>

    /**
     * Writes the array of samples (between â€“1.0 and +1.0) to standard audio.
     * If a sample is outside the range, it will be clipped.
     *
     * @param  samples the array of samples to play
     * @throws IllegalArgumentException if any sample is {@code Double.NaN}
     * @throws IllegalArgumentException if {@code samples} is {@code null}
     */
    public static void play(double[] samples) {
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (samples == null) throw new IllegalArgumentException(&quot;argument to play() is null&quot;);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        for (int i = 0; i &lt; samples.length; i++) {</span>
<span class="nc" id="L320">            play(samples[i]);</span>
        }
<span class="nc" id="L322">    }</span>

    /**
     * Plays an audio file (in WAVE, AU, AIFF, or MIDI format) and waits for it to finish.
     *
     * @param filename the name of the audio file
     * @throws IllegalArgumentException if unable to play {@code filename}
     * @throws IllegalArgumentException if {@code filename} is {@code null}
     */
    public static void play(String filename) {
<span class="nc" id="L332">        AudioInputStream ais = getAudioInputStreamFromFile(filename);</span>
<span class="nc" id="L333">        SourceDataLine line = null;</span>
<span class="nc" id="L334">        int BUFFER_SIZE = 4096; // 4K buffer</span>
        try {
<span class="nc" id="L336">            AudioFormat audioFormat = ais.getFormat();</span>
<span class="nc" id="L337">            DataLine.Info info = new DataLine.Info(SourceDataLine.class, audioFormat);</span>
<span class="nc" id="L338">            line = (SourceDataLine) AudioSystem.getLine(info);</span>
<span class="nc" id="L339">            line.open(audioFormat);</span>
<span class="nc" id="L340">            line.start();</span>
<span class="nc" id="L341">            byte[] samples = new byte[BUFFER_SIZE];</span>
            int count;
<span class="nc bnc" id="L343" title="All 2 branches missed.">            while ((count = ais.read(samples, 0, BUFFER_SIZE)) != -1) {</span>
<span class="nc" id="L344">                line.write(samples, 0, count);</span>
            }
        }
<span class="nc" id="L347">        catch (IOException | LineUnavailableException e) {</span>
<span class="nc" id="L348">            e.printStackTrace();</span>
        }
        finally {
<span class="nc bnc" id="L351" title="All 2 branches missed.">            if (line != null) {</span>
<span class="nc" id="L352">                line.drain();</span>
<span class="nc" id="L353">                line.close();</span>
            }
        }
<span class="nc" id="L356">    }</span>


    /**
     * Reads audio samples from a file (in WAVE, AU, AIFF, or MIDI format)
     * and returns them as a double array with values between â€“1.0 and +1.0.
     * The sound format must use 16-bit audio data with a sampling rate of 44,100.
     * The sound format can be either monoaural or stereo, and the bytes can
     * be stored in either little endian or big endian order.
     *
     * @param  filename the name of the audio file
     * @return the array of samples
     */
    public static double[] read(String filename) {
        // 4K buffer (must be a multiple of 2 for mono or 4 for stereo)
<span class="nc" id="L371">        int READ_BUFFER_SIZE = 4096;</span>

        // create AudioInputStream from file
<span class="nc" id="L374">        AudioInputStream fromAudioInputStream = getAudioInputStreamFromFile(filename);</span>
<span class="nc" id="L375">        AudioFormat fromAudioFormat = fromAudioInputStream.getFormat();</span>

        // normalize AudioInputStream to 44,100 Hz, 16-bit audio, mono, signed PCM, little endian
        // https://docs.oracle.com/javase/tutorial/sound/converters.html
<span class="nc" id="L379">        AudioFormat toAudioFormat = new AudioFormat((float) SAMPLE_RATE, BITS_PER_SAMPLE, MONO, SIGNED, LITTLE_ENDIAN);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (!AudioSystem.isConversionSupported(toAudioFormat, fromAudioFormat)) {</span>
<span class="nc" id="L381">            throw new IllegalArgumentException(&quot;system cannot convert from &quot; + fromAudioFormat + &quot; to &quot; + toAudioFormat);</span>
        }
<span class="nc" id="L383">        AudioInputStream toAudioInputStream = AudioSystem.getAudioInputStream(toAudioFormat, fromAudioInputStream);</span>

        // extract the audio data and convert to a double[] with each sample between -1 and +1
        try {
<span class="nc" id="L387">            QueueOfDoubles queue = new QueueOfDoubles();</span>
<span class="nc" id="L388">            byte[] bytes = new byte[READ_BUFFER_SIZE];</span>
            int count;
<span class="nc bnc" id="L390" title="All 2 branches missed.">            while ((count = toAudioInputStream.read(bytes, 0, READ_BUFFER_SIZE)) != -1) {</span>

                // little endian, monoaural
<span class="nc bnc" id="L393" title="All 2 branches missed.">                for (int i = 0; i &lt; count/2; i++) {</span>
<span class="nc" id="L394">                    double sample = ((short) (((bytes[2*i+1] &amp; 0xFF) &lt;&lt; 8) | (bytes[2*i] &amp; 0xFF))) / ((double) MAX_16_BIT);</span>
<span class="nc" id="L395">                    queue.enqueue(sample);</span>
                }

                // little endian, stereo (perhaps, for a future version that supports stereo)
                /*
                for (int i = 0; i &lt; count/4; i++) {
                    double left  = ((short) (((bytes[4*i + 1] &amp; 0xFF) &lt;&lt; 8) | (bytes[4*i + 0] &amp; 0xFF))) / ((double) MAX_16_BIT);
                    double right = ((short) (((bytes[4*i + 3] &amp; 0xFF) &lt;&lt; 8) | (bytes[4*i + 2] &amp; 0xFF))) / ((double) MAX_16_BIT);
                    double sample = (left + right) / 2.0;
                    queue.enqueue(sample);
                }
                */
            }
<span class="nc" id="L408">            toAudioInputStream.close();</span>
<span class="nc" id="L409">            fromAudioInputStream.close();</span>
<span class="nc" id="L410">            return queue.toArray();</span>
        }
<span class="nc" id="L412">        catch (IOException ioe) {</span>
<span class="nc" id="L413">            throw new IllegalArgumentException(&quot;could not read '&quot; + filename + &quot;'&quot;, ioe);</span>
        }
    }

    /**
     * Saves the double array as an audio file (using WAV, AU, or AIFF format).
     * The file extension type must be either {@code .wav}, {@code .au},
     * or {@code .aiff}.
     * The format uses a sampling rate of 44,100 Hz, 16-bit audio,
     * mono, signed PCM, ands little Endian.
     *
     * @param  filename the name of the audio file
     * @param  samples the array of samples
     * @throws IllegalArgumentException if unable to save {@code filename}
     * @throws IllegalArgumentException if {@code samples} is {@code null}
     * @throws IllegalArgumentException if {@code filename} is {@code null}
     * @throws IllegalArgumentException if {@code filename} extension is not
     *         {@code .wav}, {@code .au}, or {@code .aiff}.
     */
    public static void save(String filename, double[] samples) {
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (filename == null) {</span>
<span class="nc" id="L434">            throw new IllegalArgumentException(&quot;filename is null&quot;);</span>
        }
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (samples == null) {</span>
<span class="nc" id="L437">            throw new IllegalArgumentException(&quot;samples[] is null&quot;);</span>
        }

        // assumes 16-bit samples with sample rate = 44,100 Hz
        // use 16-bit audio, mono, signed PCM, little Endian
<span class="nc" id="L442">        AudioFormat format = new AudioFormat(SAMPLE_RATE, 16, MONO, SIGNED, LITTLE_ENDIAN);</span>
<span class="nc" id="L443">        byte[] data = new byte[2 * samples.length];</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">        for (int i = 0; i &lt; samples.length; i++) {</span>
<span class="nc" id="L445">            int temp = (short) (samples[i] * MAX_16_BIT);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (samples[i] == 1.0) temp = Short.MAX_VALUE;   // special case since 32768 not a short</span>
<span class="nc" id="L447">            data[2*i + 0] = (byte) temp;</span>
<span class="nc" id="L448">            data[2*i + 1] = (byte) (temp &gt;&gt; 8);   // little endian</span>
        }


        // now save the file
<span class="nc" id="L453">        try (ByteArrayInputStream bais = new ByteArrayInputStream(data);</span>
<span class="nc" id="L454">             AudioInputStream ais = new AudioInputStream(bais, format, samples.length)) {</span>

<span class="nc bnc" id="L456" title="All 4 branches missed.">            if (filename.endsWith(&quot;.wav&quot;) || filename.endsWith(&quot;.WAV&quot;)) {</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (!AudioSystem.isFileTypeSupported(AudioFileFormat.Type.WAVE, ais)) {</span>
<span class="nc" id="L458">                    throw new IllegalArgumentException(&quot;saving to WAVE file format is not supported on this system&quot;);</span>
                }
<span class="nc" id="L460">                AudioSystem.write(ais, AudioFileFormat.Type.WAVE, new File(filename));</span>
            }
<span class="nc bnc" id="L462" title="All 4 branches missed.">            else if (filename.endsWith(&quot;.au&quot;) || filename.endsWith(&quot;.AU&quot;)) {</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                if (!AudioSystem.isFileTypeSupported(AudioFileFormat.Type.AU, ais)) {</span>
<span class="nc" id="L464">                    throw new IllegalArgumentException(&quot;saving to AU file format is not supported on this system&quot;);</span>
                }
<span class="nc" id="L466">                AudioSystem.write(ais, AudioFileFormat.Type.AU, new File(filename));</span>
            }
<span class="nc bnc" id="L468" title="All 8 branches missed.">            else if (filename.endsWith(&quot;.aif&quot;) || filename.endsWith(&quot;.aiff&quot;) || filename.endsWith(&quot;.AIF&quot;) || filename.endsWith(&quot;.AIFF&quot;)) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">                if (!AudioSystem.isFileTypeSupported(AudioFileFormat.Type.AIFF, ais)) {</span>
<span class="nc" id="L470">                    throw new IllegalArgumentException(&quot;saving to AIFF file format is not supported on this system&quot;);</span>
                }
<span class="nc" id="L472">                AudioSystem.write(ais, AudioFileFormat.Type.AIFF, new File(filename));</span>
            }
            else {
<span class="nc" id="L475">                throw new IllegalArgumentException(&quot;file extension for saving must be .wav, .au, or .aif&quot;);</span>
            }
        }
<span class="nc" id="L478">        catch (IOException ioe) {</span>
<span class="nc" id="L479">            throw new IllegalArgumentException(&quot;unable to save file '&quot; + filename + &quot;'&quot;, ioe);</span>
<span class="nc" id="L480">        }</span>
<span class="nc" id="L481">    }</span>

    /**
     * Stops the playing of all audio files in background threads.
     */
    public static synchronized void stopInBackground() {
<span class="nc bnc" id="L487" title="All 2 branches missed.">        for (BackgroundRunnable runnable : backgroundRunnables) {</span>
<span class="nc" id="L488">            runnable.stop();</span>
<span class="nc" id="L489">        }</span>
<span class="nc" id="L490">        backgroundRunnables = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L491">    }</span>

    /**
     * Plays an audio file (in WAVE, AU, AIFF, or MIDI format) in its own
     * background thread. Multiple audio files can be played simultaneously.
     *
     * @param filename the name of the audio file
     * @throws IllegalArgumentException if unable to play {@code filename}
     * @throws IllegalArgumentException if {@code filename} is {@code null}
     */
    public static synchronized void playInBackground(final String filename) {
<span class="nc" id="L502">        BackgroundRunnable runnable = new BackgroundRunnable(filename);</span>
<span class="nc" id="L503">        new Thread(runnable).start();</span>
<span class="nc" id="L504">        backgroundRunnables.add(runnable);</span>
<span class="nc" id="L505">    }</span>

    private static class BackgroundRunnable implements Runnable {
<span class="nc" id="L508">        private volatile boolean exit = false;</span>
        private final String filename;

<span class="nc" id="L511">        public BackgroundRunnable(String filename) {</span>
<span class="nc" id="L512">            this.filename = filename;</span>
<span class="nc" id="L513">        }</span>

        // https://www3.ntu.edu.sg/home/ehchua/programming/java/J8c_PlayingSound.html
        // play a wav or aif file
        // javax.sound.sampled.Clip fails for long clips (on some systems)
        public void run() {
<span class="nc" id="L519">            AudioInputStream ais = getAudioInputStreamFromFile(filename);</span>

<span class="nc" id="L521">            SourceDataLine line = null;</span>
<span class="nc" id="L522">            int BUFFER_SIZE = 4096; // 4K buffer</span>

            try {
<span class="nc" id="L525">                AudioFormat audioFormat = ais.getFormat();</span>
<span class="nc" id="L526">                DataLine.Info info = new DataLine.Info(SourceDataLine.class, audioFormat);</span>
<span class="nc" id="L527">                line = (SourceDataLine) AudioSystem.getLine(info);</span>
<span class="nc" id="L528">                line.open(audioFormat);</span>
<span class="nc" id="L529">                line.start();</span>
<span class="nc" id="L530">                byte[] samples = new byte[BUFFER_SIZE];</span>
                int count;
<span class="nc bnc" id="L532" title="All 4 branches missed.">                while (!exit &amp;&amp; (count = ais.read(samples, 0, BUFFER_SIZE)) != -1) {</span>
<span class="nc" id="L533">                    line.write(samples, 0, count);</span>
                }
            }
<span class="nc" id="L536">            catch (IOException | LineUnavailableException e) {</span>
<span class="nc" id="L537">                e.printStackTrace();</span>
            }
            finally {
<span class="nc bnc" id="L540" title="All 2 branches missed.">                if (line != null) {</span>
<span class="nc" id="L541">                    line.drain();</span>
<span class="nc" id="L542">                    line.close();</span>
                }
            }
<span class="nc" id="L545">        }</span>

        public void stop() {
<span class="nc" id="L548">            exit = true;</span>
<span class="nc" id="L549">        }</span>
    }


    /**
     * Loops an audio file (in WAVE, AU, AIFF, or MIDI format) in its
     * own background thread.
     *
     * @param filename the name of the audio file
     * @throws IllegalArgumentException if {@code filename} is {@code null}
     * @deprecated to be removed in a future update, as it doesn't interact
     *             well with {@link #playInBackground(String filename)} or
     *             {@link #stopInBackground()}.
     */
    @Deprecated
    public static synchronized void loopInBackground(String filename) {
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (filename == null) throw new IllegalArgumentException();</span>

<span class="nc" id="L567">        final AudioInputStream ais = getAudioInputStreamFromFile(filename);</span>

        try {
<span class="nc" id="L570">            Clip clip = AudioSystem.getClip();</span>
            // Clip clip = (Clip) AudioSystem.getLine(new Line.Info(Clip.class));
<span class="nc" id="L572">            clip.open(ais);</span>
<span class="nc" id="L573">            clip.loop(Clip.LOOP_CONTINUOUSLY);</span>
        }
<span class="nc" id="L575">        catch (IOException | LineUnavailableException e) {</span>
<span class="nc" id="L576">            e.printStackTrace();</span>
<span class="nc" id="L577">        }</span>

        // keep JVM open
<span class="nc" id="L580">        new Thread(new Runnable() {</span>
            public void run() {
                while (true) {
                    try {
<span class="nc" id="L584">                        Thread.sleep(1000);</span>
                    }
<span class="nc" id="L586">                    catch (InterruptedException e) {</span>
<span class="nc" id="L587">                        e.printStackTrace();</span>
<span class="nc" id="L588">                    }</span>
                }
            }
<span class="nc" id="L591">        }).start();</span>
<span class="nc" id="L592">    }</span>


    /**
     * Turns on audio recording.
     */
    public static void startRecording() {
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (!isRecording) {</span>
<span class="nc" id="L600">            recordedSamples = new QueueOfDoubles();</span>
<span class="nc" id="L601">            isRecording = true;</span>
        }
        else {
<span class="nc" id="L604">            throw new IllegalStateException(&quot;startRecording() must not be called twice in a row&quot;);</span>
        }
<span class="nc" id="L606">    }</span>

    /**
     * Turns off audio recording and returns the recorded samples.
     * @return the array of recorded samples
     */
    public static double[] stopRecording() {
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (isRecording) {</span>
<span class="nc" id="L614">            double[] results = recordedSamples.toArray();</span>
<span class="nc" id="L615">            isRecording = false;</span>
<span class="nc" id="L616">            recordedSamples = null;</span>
<span class="nc" id="L617">            return results;</span>
        }
        else {
<span class="nc" id="L620">            throw new IllegalStateException(&quot;stopRecording() must be called after calling startRecording()&quot;);</span>
        }
    }


    /***************************************************************************
     * Helper class for reading and recording audio.
     ***************************************************************************/
<span class="nc" id="L628">    private static class QueueOfDoubles {</span>
        private static final int INIT_CAPACITY = 16;
        private double[] a;   // array of doubles
        private int n;        // number of items in queue

        // create an empty queue
<span class="nc" id="L634">        public QueueOfDoubles() {</span>
<span class="nc" id="L635">            a = new double[INIT_CAPACITY];</span>
<span class="nc" id="L636">            n = 0;</span>
<span class="nc" id="L637">        }</span>

        // resize the underlying array holding the items
        private void resize(int capacity) {
<span class="nc bnc" id="L641" title="All 2 branches missed.">            assert capacity &gt;= n;</span>
<span class="nc" id="L642">            double[] temp = new double[capacity];</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++)</span>
<span class="nc" id="L644">                temp[i] = a[i];</span>
<span class="nc" id="L645">            a = temp;</span>
<span class="nc" id="L646">        }</span>

        // enqueue item onto the queue
        public void enqueue(double item) {
<span class="nc bnc" id="L650" title="All 2 branches missed.">            if (n == a.length) resize(2*a.length);    // double length of array if necessary</span>
<span class="nc" id="L651">            a[n++] = item;                            // add item</span>
<span class="nc" id="L652">        }</span>


        // number of items in queue
        public int size() {
<span class="nc" id="L657">            return n;</span>
        }

        // return the items as an array of length n
        public double[] toArray() {
<span class="nc" id="L662">            double[] result = new double[n];</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++)</span>
<span class="nc" id="L664">                result[i] = a[i];</span>
<span class="nc" id="L665">            return result;</span>
        }

    }


    /**
     * Test client - plays some sound files and concert A.
     *
     * @param args the command-line arguments (none should be specified)
     */
    public static void main(String[] args) {
        // 440 Hz for 1 sec
<span class="nc" id="L678">        double freq = 440.0;</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">        for (int i = 0; i &lt;= Audio.SAMPLE_RATE; i++) {</span>
<span class="nc" id="L680">            Audio.play(0.5 * Math.sin(2*Math.PI * freq * i / Audio.SAMPLE_RATE));</span>
        }


<span class="nc" id="L684">        String base = &quot;samples/&quot;;</span>

        // play some sound files
<span class="nc" id="L687">        Audio.play(base + &quot;test.wav&quot;);          // helicopter</span>
<span class="nc" id="L688">        Audio.play(base + &quot;test-22050.wav&quot;);    // twenty-four</span>
<span class="nc" id="L689">        Audio.play(base + &quot;test.midi&quot;);         // a Mozart measure</span>

        // a sound loop
<span class="nc bnc" id="L692" title="All 2 branches missed.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="nc" id="L693">            Audio.play(base + &quot;BaseDrum.wav&quot;);</span>
<span class="nc" id="L694">            Audio.play(base + &quot;SnareDrum.wav&quot;);</span>
        }

        // need to call this in non-interactive stuff so the program doesn't terminate
        // until all the sound leaves the speaker.
<span class="nc" id="L699">        Audio.drain();</span>
<span class="nc" id="L700">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>