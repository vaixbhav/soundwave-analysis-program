<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConcreteSoundWave.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mp1b-anisidvai</a> &gt; <a href="index.source.html" class="el_package">cpen221.soundwaves</a> &gt; <span class="el_source">ConcreteSoundWave.java</span></div><h1>ConcreteSoundWave.java</h1><pre class="source lang-java linenums">package cpen221.soundwaves;

import cpen221.soundwaves.soundutils.FilterType;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Arrays;

public class ConcreteSoundWave implements SoundWave {

    private double[] leftChannel;
    private double[] rightChannel;

    // Representation Invariants:
    //  both leftChannel and rightChannel must have the same length
    //  all elements in leftChannel and rightChanel must represent valid audio samples from (-1 to 1)
    //  ConcreteSoundWave objects should be immutable after initialization.

    // Abstraction Functions:
    //  ConcreteSoundWave object represents sound wave with separate left and right channels
    //  - leftChannel: an array of doubles representing audio samples in left channel
    //  - rightChannel: an array of doubles representing audio samples in right channel

    /**
     * Create an instance of {@code SoundWave} with specified amplitude values for
     * the left and right channel (assuming stereo).
     *
     * @param leftChannel  left channel. leftChannel is not null.
     * @param rightChannel right channel. rightChannel is not null
     *
     * Modifies this.
     */
<span class="fc" id="L34">    public ConcreteSoundWave(double[] leftChannel, double[] rightChannel) {</span>
<span class="fc" id="L35">        this.leftChannel = leftChannel;</span>
<span class="fc" id="L36">        this.rightChannel = rightChannel;</span>
<span class="fc" id="L37">    }</span>


    /**
     * Gets the left channel of this wave.
     *
     * @return left channel of this wave.
     */
    @Override
    public double[] getLeftChannel() {
<span class="fc" id="L47">        double[] leftChannelInstance = new double[this.leftChannel.length];</span>
<span class="fc" id="L48">        System.arraycopy(this.leftChannel, 0, leftChannelInstance, 0, this.leftChannel.length);</span>
<span class="fc" id="L49">        return leftChannelInstance;</span>
    }


    /**
     * Gets the right channel of this wave.
     *
     * @return right channel of this wave.
     */
    @Override
    public double[] getRightChannel() {
<span class="fc" id="L60">        double[] rightChannelInstance = new double[this.rightChannel.length];</span>
<span class="fc" id="L61">        System.arraycopy(this.rightChannel, 0, rightChannelInstance, 0, this.rightChannel.length);</span>
<span class="fc" id="L62">        return rightChannelInstance;</span>
    }


    /**
     * Gets the duration of the sound wave.
     *
     * @return duration of the sound wave.
     */
    @Override
    public double duration() {
<span class="nc" id="L73">        return (this.leftChannel.length * ( 1.0 / SAMPLES_PER_SECOND));</span>
    }


    /**
     * Append the given channels sound wave to the end of this wave.
     *
     * @param lchannel the left channel of the sound wave to append.
     *                 lchannel is not null.
     * @param rchannel the right channel of the sound wave to append.
     *                 rchannel is not null.
     *
     * Modifies this.
     */
    @Override
    public void append(double[] lchannel, double[] rchannel) {

<span class="nc" id="L90">        double[] leftChannelAfter = new double[lchannel.length + this.leftChannel.length];</span>
<span class="nc" id="L91">        double[] rightChannelAfter = new double[rchannel.length + this.rightChannel.length];</span>

<span class="nc" id="L93">        System.arraycopy(this.leftChannel, 0, leftChannelAfter, 0, this.leftChannel.length);</span>
<span class="nc" id="L94">        System.arraycopy(this.rightChannel, 0, rightChannelAfter, 0, this.rightChannel.length);</span>

<span class="nc" id="L96">        System.arraycopy(lchannel, 0, leftChannelAfter, this.leftChannel.length, lchannel.length);</span>
<span class="nc" id="L97">        System.arraycopy(rchannel, 0, rightChannelAfter, this.rightChannel.length, rchannel.length);</span>

<span class="nc" id="L99">        this.leftChannel = leftChannelAfter;</span>
<span class="nc" id="L100">        this.rightChannel = rightChannelAfter;</span>

<span class="nc" id="L102">    }</span>


    /**
     * Appends the given sound wave to the end of this wave.
     *
     * @param other the sound wave to append to this wave.
     *
     * Modifies this.
     */
    @Override
    public void append(SoundWave other) {

<span class="nc" id="L115">        double[] lchannel = other.getLeftChannel();</span>
<span class="nc" id="L116">        double[] rchannel = other.getRightChannel();</span>

<span class="nc" id="L118">        this.append(lchannel, rchannel);</span>

<span class="nc" id="L120">    }</span>


    /**
     * Creates a new wave by adding the given wave to this wave.
     *
     * @param other the wave to add to this wave.
     *              other is not null.
     * @return the new wave obtained by adding both waves.
     */
    @Override
    public SoundWave add(SoundWave other) {

        SoundWave otherWave, thisWave;

<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (this.getLeftChannel().length &gt; other.getLeftChannel().length) {</span>
<span class="nc" id="L136">            otherWave = makeSameSize(other, this);</span>
<span class="nc" id="L137">            thisWave = new ConcreteSoundWave(this.getLeftChannel(), this.getRightChannel());</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        } else if (this.getLeftChannel().length &lt; other.getLeftChannel().length) {</span>
<span class="nc" id="L139">            thisWave = makeSameSize(this, other);</span>
<span class="nc" id="L140">            otherWave = new ConcreteSoundWave(other.getLeftChannel(), other.getRightChannel());</span>
        } else {
<span class="nc" id="L142">            thisWave = new ConcreteSoundWave(this.getLeftChannel(), this.getRightChannel());</span>
<span class="nc" id="L143">            otherWave = new ConcreteSoundWave(other.getLeftChannel(), other.getRightChannel());</span>
        }

<span class="nc" id="L146">        double[] newLChannel = new double[thisWave.getRightChannel().length];</span>
<span class="nc" id="L147">        double[] newRChannel = new double[thisWave.getRightChannel().length];</span>

<span class="nc bnc" id="L149" title="All 2 branches missed.">        for (int t = 0; t &lt; thisWave.getRightChannel().length; t++) {</span>
<span class="nc" id="L150">            newLChannel[t] = thisWave.getLeftChannel()[t] + otherWave.getLeftChannel()[t];</span>
<span class="nc" id="L151">            newRChannel[t] = thisWave.getRightChannel()[t] + otherWave.getRightChannel()[t];</span>
        }

<span class="nc" id="L154">        SoundWave normalizedWave = normalize(new ConcreteSoundWave(newLChannel, newRChannel));</span>
<span class="nc" id="L155">        return new ConcreteSoundWave(normalizedWave.getLeftChannel(), normalizedWave.getRightChannel());</span>
    }


    /**
     * Create a new wave by adding an echo to this wave.
     *
     * @param delta &gt; 0. delta, in seconds, is the time lag between this wave and
     *              the echo wave.
     * @param alpha &gt; 0. alpha is the damping factor applied to the echo wave.
     * @return a new sound wave with an echo.
     */
    @Override
    public SoundWave addEcho(double delta, double alpha) {
<span class="nc" id="L169">        double[] echoLChannel = new double[(int) (this.leftChannel.length + delta)];</span>
<span class="nc" id="L170">        double[] echoRChannel = new double[(int) (this.rightChannel.length + delta)];</span>


<span class="nc bnc" id="L173" title="All 2 branches missed.">        if(delta &lt; 0){</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            for (int t = 0; t &lt; echoRChannel.length; t++) {</span>
<span class="nc" id="L175">                echoRChannel[t] = this.leftChannel[t - (int) delta] * alpha;</span>
<span class="nc" id="L176">                echoLChannel[t] = this.rightChannel[t- (int) delta] * alpha;</span>
            }
        } else {
<span class="nc bnc" id="L179" title="All 2 branches missed.">            for (int t = 0; t &lt; delta; t++) {</span>
<span class="nc" id="L180">                echoRChannel[t] = 0;</span>
<span class="nc" id="L181">                echoLChannel[t] = 0;</span>
            }
<span class="nc bnc" id="L183" title="All 2 branches missed.">            for (int t = 0; t &lt; this.leftChannel.length; t++) {</span>
<span class="nc" id="L184">                echoRChannel[t + (int) delta] = this.leftChannel[t] * alpha;</span>
<span class="nc" id="L185">                echoLChannel[t + (int) delta] = this.rightChannel[t] * alpha;</span>
            }
        }

<span class="nc" id="L189">        SoundWave echoWave = new ConcreteSoundWave(echoLChannel, echoRChannel);</span>
<span class="nc" id="L190">        SoundWave wave = (new ConcreteSoundWave(this.getLeftChannel(), this.getRightChannel()));</span>
<span class="nc" id="L191">        return wave.add(echoWave);</span>
    }


    /**
     * Scale the amplitude of this wave by a scaling factor.
     * After scaling, the amplitude values are normalized to remain
     * between -1 and +1.
     *
     * @param scalingFactor is a value &gt; 0.
     *
     * Modifies this.
     */
    @Override
    public void scale(double scalingFactor) {
<span class="nc" id="L206">        double[] copyLeft = Arrays.copyOf(getLeftChannel(), this.leftChannel.length);</span>
<span class="nc" id="L207">        double[] copyRight = Arrays.copyOf(getRightChannel(), this.rightChannel.length);</span>

<span class="nc bnc" id="L209" title="All 2 branches missed.">        for (int t = 0; t &lt; copyLeft.length; t++) {</span>
<span class="nc" id="L210">            copyLeft[t] *= scalingFactor;</span>
<span class="nc" id="L211">            copyRight[t] *= scalingFactor;</span>
        }

<span class="nc" id="L214">        SoundWave newWave = normalize(new ConcreteSoundWave(copyLeft, copyRight));</span>

<span class="nc" id="L216">        this.leftChannel = newWave.getLeftChannel();</span>
<span class="nc" id="L217">        this.rightChannel = newWave.getRightChannel();</span>

<span class="nc" id="L219">    }</span>


    /**
     * Determine if this wave fully contains the other sound wave as a pattern.
     *
     * @param other is the wave to search for in this wave.
     *              other is not null.
     * @return true if the other wave is contained in this after amplitude scaling,
     * and false if the other wave is not contained in this with any
     * possible amplitude scaling.
     */
    @Override
    public boolean contains(SoundWave other) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (other.getLeftChannel().length &gt; this.leftChannel.length) {</span>
<span class="nc" id="L234">            return false;</span>
        }

<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (other.getLeftChannel().length == 0) {</span>
<span class="nc" id="L238">            return true;</span>
        }

<span class="nc" id="L241">        double[] lchannel = other.getLeftChannel();</span>
<span class="nc" id="L242">        double[] rchannel = other.getRightChannel();</span>

<span class="nc bnc" id="L244" title="All 2 branches missed.">        for (int startPoint = 0; startPoint &lt;= (this.leftChannel.length - other.getLeftChannel().length); startPoint++) {</span>

<span class="nc" id="L246">            boolean contains = false;</span>
<span class="nc" id="L247">            double scaleFactor = Math.abs(this.rightChannel[startPoint] / rchannel[0]);</span>

<span class="nc bnc" id="L249" title="All 2 branches missed.">            for (int t = startPoint; t &lt; startPoint + lchannel.length; t++) {</span>
<span class="nc" id="L250">                contains = true;</span>
<span class="nc bnc" id="L251" title="All 4 branches missed.">                if (Math.abs(Math.abs(this.leftChannel[t] / lchannel[t - startPoint])  - scaleFactor) &gt; 0.00001 || Math.abs(this.rightChannel[t] / rchannel[t - startPoint]  - scaleFactor) &gt; 0.00001) {</span>
<span class="nc" id="L252">                    contains = false;</span>
<span class="nc" id="L253">                    break;</span>
                }
            }
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (contains) {</span>
<span class="nc" id="L257">                return true;</span>
            }
        }
<span class="nc" id="L260">        return false;</span>
    }


    /**
     * Determine the similarity between this wave and another wave.
     * The similarity metric, gamma, is the sum of squares of
     * instantaneous differences.
     *
     * @param other the wave to be compared for similarity.
     *              other is not null.
     * @return the similarity between this wave and other.
     */
    @Override
    public double similarity(SoundWave other) {

        SoundWave otherWave, thisWave;

<span class="fc" id="L278">        double bestGamma1 = 0.0;</span>
<span class="fc" id="L279">        double bestGamma2 = 0.0;</span>
        double gamma1, gamma2;

<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        if (this.getLeftChannel().length &gt; other.getLeftChannel().length) {</span>
<span class="nc" id="L283">            otherWave = makeSameSize(other, this);</span>
<span class="nc" id="L284">            thisWave = new ConcreteSoundWave(this.getLeftChannel(), this.getRightChannel());</span>
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        } else if (this.getLeftChannel().length &lt; other.getLeftChannel().length) {</span>
<span class="nc" id="L286">            thisWave = makeSameSize(this, other);</span>
<span class="nc" id="L287">            otherWave = new ConcreteSoundWave(other.getLeftChannel(), other.getRightChannel());</span>
        } else {
<span class="fc" id="L289">            thisWave = new ConcreteSoundWave(this.getLeftChannel(), this.getRightChannel());</span>
<span class="fc" id="L290">            otherWave = new ConcreteSoundWave(other.getLeftChannel(), other.getRightChannel());</span>
        }

<span class="fc" id="L293">        double[] betaArray = getBetaArray();</span>

<span class="fc bfc" id="L295" title="All 2 branches covered.">        for (double beta : betaArray) {</span>
<span class="fc" id="L296">            gamma1 = this.gamma(thisWave.getLeftChannel(), thisWave.getRightChannel(), otherWave.getLeftChannel(), otherWave.getRightChannel(), beta);</span>
<span class="fc" id="L297">            gamma2 = this.gamma(otherWave.getLeftChannel(), otherWave.getRightChannel(), thisWave.getLeftChannel(), thisWave.getRightChannel(), beta);</span>

<span class="fc bfc" id="L299" title="All 2 branches covered.">            if ( gamma1 &gt; bestGamma1) {</span>
<span class="fc" id="L300">                bestGamma1 = gamma1;</span>
            }

<span class="fc bfc" id="L303" title="All 2 branches covered.">            if ( gamma2 &gt; bestGamma2) {</span>
<span class="fc" id="L304">                bestGamma2 = gamma2;</span>
            }
        }

<span class="fc" id="L308">        return (bestGamma2 + bestGamma1) / 2.0;</span>
    }


    /**
     * Return the frequency of the component with the greatest amplitude
     * contribution to this wave. This component is the highest frequency obtained after
     * applying the Discrete Fourier Transform to this wave.
     *
     * @return the frequency of the wave component corresponding of highest amplitude.
     */
    @Override
    public double highestAmplitudeFrequencyComponent() {
<span class="nc" id="L321">        ComplexNumber[] leftFrequencyArray = this.fourierTransform(this.getLeftChannel());</span>
<span class="nc" id="L322">        ComplexNumber[] rightFrequencyArray = this.fourierTransform(this.getRightChannel());</span>

<span class="nc" id="L324">        ComplexNumber maxLeftFrequency = new ComplexNumber(0, 0);</span>
<span class="nc" id="L325">        ComplexNumber maxRightFrequency = new ComplexNumber(0, 0);</span>

<span class="nc bnc" id="L327" title="All 2 branches missed.">        for (int k = 0; k &lt; leftFrequencyArray.length; k++) {</span>
<span class="nc" id="L328">            maxLeftFrequency = ComplexNumber.max(maxLeftFrequency, leftFrequencyArray[k]);</span>
<span class="nc" id="L329">            maxRightFrequency = ComplexNumber.max(maxRightFrequency, rightFrequencyArray[k]);</span>
        }

<span class="nc" id="L332">        ComplexNumber maxFrequency = ComplexNumber.max(maxRightFrequency, maxLeftFrequency);</span>
<span class="nc" id="L333">        return maxFrequency.toReal();</span>
    }


    /**
     * Filters this sound wave based on the filter type and the threshold frequencies specified.
     *
     * @param type the type of filter through which the frequencies must be passed
     * @param frequencies the thresholds for filtering
     * @return a ConcreteSoundwave object with the filtered frequencies as channels
     */
    @Override
    public SoundWave filter(FilterType type, Double... frequencies) {

<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (frequencies.length &gt; 2) {</span>
<span class="nc" id="L348">            throw new IllegalArgumentException(&quot;Can not enter more than two filters.&quot;);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        } else if (frequencies.length == 0) {</span>
<span class="nc" id="L350">            return new ConcreteSoundWave(this.getLeftChannel(), this.getRightChannel());</span>
        } else {

<span class="nc" id="L353">            List&lt;Double&gt; thresholds = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L354">            Collections.addAll(thresholds, frequencies);</span>
<span class="nc" id="L355">            Collections.sort(thresholds);</span>

<span class="nc" id="L357">            double[] leftFrequencyArray = getFrequencyArray(fourierTransform(this.getLeftChannel()));</span>
<span class="nc" id="L358">            double[] rightFrequencyArray = getFrequencyArray(fourierTransform(this.getRightChannel()));</span>

<span class="nc" id="L360">            List&lt;Double&gt; leftChannelList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L361">            List&lt;Double&gt; rightChannelList = new ArrayList&lt;&gt;();</span>

            double[] rightChannelArray;
            double[] leftChannelArray;

<span class="nc" id="L366">            SoundWave filteredWave = null;</span>

<span class="nc bnc" id="L368" title="All 4 branches missed.">            switch (type) {</span>
                case LOWPASS -&gt; {
<span class="nc bnc" id="L370" title="All 2 branches missed.">                    if (thresholds.size() == 1) {</span>
<span class="nc" id="L371">                        addFrequencyToList(leftFrequencyArray, leftChannelList, thresholds.get(0), -1, 1);</span>
<span class="nc" id="L372">                        addFrequencyToList(rightFrequencyArray, rightChannelList, thresholds.get(0), -1, 1);</span>

<span class="nc" id="L374">                        rightChannelArray = new double[rightChannelList.size()];</span>
<span class="nc" id="L375">                        leftChannelArray = new double[leftChannelList.size()];</span>

<span class="nc" id="L377">                        copyListToArray(rightChannelList, rightChannelArray);</span>
<span class="nc" id="L378">                        copyListToArray(leftChannelList, leftChannelArray);</span>

<span class="nc" id="L380">                        filteredWave = new ConcreteSoundWave(leftChannelArray, rightChannelArray);</span>

                    } else {
<span class="nc" id="L383">                        throw new IllegalArgumentException(&quot;Invalid frequencies for the given type&quot;);</span>
                    }
                }
                case BANDPASS -&gt; {
<span class="nc bnc" id="L387" title="All 2 branches missed.">                    if (thresholds.size() &gt; 1) {</span>
<span class="nc" id="L388">                        addFrequencyToList(leftFrequencyArray, leftChannelList, thresholds.get(0), thresholds.get(1), 2);</span>
<span class="nc" id="L389">                        addFrequencyToList(rightFrequencyArray, rightChannelList, thresholds.get(0), thresholds.get(1), 2);</span>

<span class="nc" id="L391">                        rightChannelArray = new double[rightChannelList.size()];</span>
<span class="nc" id="L392">                        leftChannelArray = new double[leftChannelList.size()];</span>

<span class="nc" id="L394">                        copyListToArray(rightChannelList, rightChannelArray);</span>
<span class="nc" id="L395">                        copyListToArray(leftChannelList, leftChannelArray);</span>

<span class="nc" id="L397">                        filteredWave = new ConcreteSoundWave(leftChannelArray, rightChannelArray);</span>
                    } else {
<span class="nc" id="L399">                        throw new IllegalArgumentException(&quot;Invalid frequencies for the given type&quot;);</span>
                    }
                }
                case HIGHPASS -&gt; {
<span class="nc bnc" id="L403" title="All 2 branches missed.">                    if (thresholds.size() == 1) {</span>
<span class="nc" id="L404">                        addFrequencyToList(leftFrequencyArray, leftChannelList, -1, thresholds.get(0), 3);</span>
<span class="nc" id="L405">                        addFrequencyToList(rightFrequencyArray, rightChannelList, -1, thresholds.get(0), 3);</span>

<span class="nc" id="L407">                        rightChannelArray = new double[rightChannelList.size()];</span>
<span class="nc" id="L408">                        leftChannelArray = new double[leftChannelList.size()];</span>

<span class="nc" id="L410">                        copyListToArray(rightChannelList, rightChannelArray);</span>
<span class="nc" id="L411">                        copyListToArray(leftChannelList, leftChannelArray);</span>

<span class="nc" id="L413">                        filteredWave = new ConcreteSoundWave(leftChannelArray, rightChannelArray);</span>
                    } else {
<span class="nc" id="L415">                        throw new IllegalArgumentException(&quot;Invalid frequencies for the given type&quot;);</span>
                    }
                }
            }
<span class="nc" id="L419">            return filteredWave;</span>
        }
    }



    /*
     * Generate a fractal waveform from the given sound wave
     * (this is for fun!)
     * @param period the fractal periodicity, &gt;= 1
     * @return a fractalized ConcreteSoundWave
    public ConcreteSoundWave fractalize(int period) {
        final long SCALE = (long) period * SAMPLES_PER_SECOND;
        double[] lchannel = this.getLeftChannel();
        double[] rchannel = this.getRightChannel();

        double[] newLChannel = Arrays.stream(lchannel).mapToLong(t -&gt; (int)(SCALE * t))
                .map(t -&gt; t &amp; (t &gt;&gt;&gt; 3) % SCALE)
                .mapToDouble(t -&gt; (double) t / SCALE)
                .toArray();
        double[] newRChannel = Arrays.stream(rchannel).mapToLong(t -&gt; (long)(SCALE * t))
                .map(t -&gt; t &amp; (t &gt;&gt;&gt; 3) % SCALE)
                .mapToDouble(t -&gt; (double) t / SCALE)
                .toArray();
        // One could also try:
        // t &amp; (t &gt;&gt; 3) &amp; (t &gt;&gt; 8) % SCALE;
        return new ConcreteSoundWave(newLChannel, newRChannel);
    }
    */



    //HELPER FUNCTIONS:

    /**
     * Takes samples as functions of time and maps it to the frequency domain.
     * (i.e. performs a Fourier Transform to obtain the frequencies
     * of the sine waves composing the compound sound wave)
     *
     * @param displacementArray the array corresponding to samples
     *                          on which the Fourier Transformation will be applied
     * @return array with fourier transformed frequencies
     */
    private ComplexNumber[] fourierTransform(double[] displacementArray){
<span class="nc" id="L463">        double N = displacementArray.length;</span>
<span class="nc" id="L464">        ArrayList&lt;ComplexNumber&gt; frequencyList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L465">        ComplexNumber euler = new ComplexNumber(0, 0);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        for(int k = 0; k &lt; N; k++){</span>
<span class="nc" id="L467">            frequencyList.add(k, new ComplexNumber(0, 0));</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">            for(int t = 0; t &lt; N; t++){</span>
<span class="nc" id="L469">                frequencyList.set(k, frequencyList.get(k).add(euler.eulerRepresentation((-2 * Math.PI * k * t) / N).multiply(displacementArray[t])));</span>
            }
        }
<span class="nc" id="L472">        ComplexNumber[] frequencyArray = new ComplexNumber[frequencyList.toArray().length];</span>

<span class="nc bnc" id="L474" title="All 2 branches missed.">        for(int k =0; k &lt; frequencyList.toArray().length; k++){</span>
<span class="nc" id="L475">            frequencyArray[k] = frequencyList.get(k);</span>
        }
<span class="nc" id="L477">        return frequencyArray;</span>
    }


    /**
     * Calculates gamma, the intermediate similarity metric for the two given sound waves.
     *
     * @param leftChannelOne the left channel of the first wave.
     * @param rightChannelOne the left channel of the second wave.
     * @param leftChannelTwo the right channel of the first wave.
     * @param rightChannelTwo the left channel of the second wave.
     * @param beta the factor by which the values of channels
     *             of the second wave are scaled.
     *             beta must be chosen to minimize gamma.
     * @return gamma, the intermediate similarity metric between two waves.
     */
    private double gamma(double[] leftChannelOne, double[] rightChannelOne, double[] leftChannelTwo, double[] rightChannelTwo, double beta){
<span class="fc" id="L494">        return 1.0 / (1 + this.summator(rightChannelOne, rightChannelTwo, beta) + this.summator(leftChannelOne, leftChannelTwo, beta));</span>
    }


    /**
     * Calculates the summation of square of the difference between
     * corresponding values first and second channels, where the
     * second channel values are scaled by beta.
     *
     * @param channelOne the first channel of samples.
     * @param channelTwo the second channel of samples.
     * @param beta the factor by which the values of channels
     *             of the second wave are scaled.
     *             beta must be chosen to minimize gamma.
     * @return the summation of the squares of differences between the
     *         first channel values and second channel values scaled by beta.
     */
    private double summator(double[] channelOne, double[] channelTwo, double beta){

<span class="fc" id="L513">        double summation = 0.0;</span>

<span class="fc bfc" id="L515" title="All 2 branches covered.">        for(int t = 0; t &lt; channelOne.length; t++){</span>
<span class="fc" id="L516">            summation += Math.pow((channelOne[t] - beta * channelTwo[t]), 2);</span>
        }

<span class="fc" id="L519">        return summation;</span>
    }


    /**
     * Creates a new wave with the same sample values as the smaller wave
     * and zero valued samples at the end such that its duration
     * is the same as the duration of the bigger wave.
     *
     * @param smallWave the wave with the smaller duration.
     * @param bigWave the wave with the bigger duration.
     * @return a new wave with the same sample values as the smaller wave
     *         and the same duration as the bigger wave.
     */
    private static SoundWave makeSameSize(SoundWave smallWave, SoundWave bigWave){

<span class="nc" id="L535">        SoundWave newSoundWave = new ConcreteSoundWave(smallWave.getLeftChannel(), smallWave.getRightChannel());</span>

<span class="nc" id="L537">        int diff = bigWave.getLeftChannel().length - smallWave.getLeftChannel().length;</span>
<span class="nc" id="L538">        newSoundWave.append(new double[diff], new double[diff]);</span>

<span class="nc" id="L540">        return new ConcreteSoundWave(newSoundWave.getLeftChannel(), newSoundWave.getRightChannel());</span>
    }


    /**
     * Normalizes both channels of the given wave.
     *
     * @param wave the wave to be normalized.
     * @return the normalized wave.
     */
    private static SoundWave normalize(SoundWave wave){

<span class="nc" id="L552">        double[] lchannel = wave.getLeftChannel();</span>
<span class="nc" id="L553">        double[] rchannel = wave.getRightChannel();</span>

<span class="nc" id="L555">        double maxLeft = Arrays.stream(lchannel).max().orElse(0.0);</span>
<span class="nc" id="L556">        double maxRight = Arrays.stream(rchannel).max().orElse(0.0);</span>

<span class="nc" id="L558">        double minLeft = Arrays.stream(lchannel).min().orElse(0.0);</span>
<span class="nc" id="L559">        double minRight = Arrays.stream(rchannel).min().orElse(0.0);</span>

<span class="nc" id="L561">        double left = Math.abs(Math.max(Math.abs(maxLeft), Math.abs(minLeft)));</span>
<span class="nc" id="L562">        double right = Math.abs(Math.max(Math.abs(maxRight), Math.abs(minRight)));</span>

<span class="nc" id="L564">        SoundWave leftWave = new ConcreteSoundWave(lchannel, new double[rchannel.length]);</span>
<span class="nc" id="L565">        SoundWave rightWave = new ConcreteSoundWave(new double[lchannel.length], rchannel);</span>

<span class="nc bnc" id="L567" title="All 2 branches missed.">        if(left &gt; 1.0) {</span>
<span class="nc" id="L568">            leftWave.scale((1.0 / left));</span>
        }
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if(right &gt; 1.0) {</span>
<span class="nc" id="L571">            rightWave.scale((1.0 / right));</span>
        }

<span class="nc" id="L574">        return new ConcreteSoundWave(leftWave.getLeftChannel(), rightWave.getRightChannel());</span>
    }


    /**
     * Converts the complex number frequency array to a real number array.
     *
     * @param fourierTransformedArray the frequency array with Complex Number frequencies
     *                                (cannot be null)
     * @return frequencies corresponding to the real values of the complex number frequencies.
     */
    private static double[] getFrequencyArray(ComplexNumber[] fourierTransformedArray){

<span class="nc" id="L587">        double[] frequencies = new double[fourierTransformedArray.length];</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">        for (int i = 0; i &lt; fourierTransformedArray.length; i++) {</span>
<span class="nc" id="L589">            frequencies[i] = fourierTransformedArray[i].toReal();</span>
        }
<span class="nc" id="L591">        return frequencies;</span>
    }


    /**
     * Copies all the values from a list to an array.
     *
     * @param sourceList the list from which the values must be copied.
     * @param destArray the array to which the values must be copied.
     *
     * Modifies dest.
     */
    private static void copyListToArray(List&lt;Double&gt; sourceList, double[] destArray){
<span class="nc" id="L604">        int index = 0;</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">        for (Double frequency : sourceList) {</span>
<span class="nc" id="L606">            destArray[index] = frequency;</span>
<span class="nc" id="L607">            index++;</span>
<span class="nc" id="L608">        }</span>
<span class="nc" id="L609">    }</span>

    /**
     * Adds the frequencies that satisfy the filer requirements to a given list.
     *
     * @param sourceFrequencyArray the array from which the values must be copied.
     * @param destFrequencyList the list to which the values must be copied.
     * @param lowpassThreshold the threshold frequency for the LOWPASS filter.
     * @param highpassThreshold the threshold frequency for the HIGHPASS filter.
     * @param type the type of filter (1 --&gt; LOWPASS, 2 --&gt; BANDPASS, 3 --&gt; HIGHPASS).
     *
     * Modifies src.
     */
    private static void addFrequencyToList(double[] sourceFrequencyArray, List&lt;Double&gt; destFrequencyList, double lowpassThreshold, double highpassThreshold, int type){
<span class="nc" id="L623">        int index = 0;</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">        for (double frequency : sourceFrequencyArray) {</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (type == 1) {</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                if ((frequency &lt; lowpassThreshold)) {</span>
<span class="nc" id="L627">                    destFrequencyList.add(index, frequency);</span>
<span class="nc" id="L628">                    index++;</span>
                }
<span class="nc bnc" id="L630" title="All 2 branches missed.">            } else if (type == 2) {</span>
<span class="nc bnc" id="L631" title="All 4 branches missed.">                if ((frequency &gt; lowpassThreshold) &amp;&amp; (frequency &lt; highpassThreshold)) {</span>
<span class="nc" id="L632">                    destFrequencyList.add(index, frequency);</span>
<span class="nc" id="L633">                    index++;</span>
                }
            } else {
<span class="nc bnc" id="L636" title="All 2 branches missed.">                if ((frequency &gt; highpassThreshold)) {</span>
<span class="nc" id="L637">                    destFrequencyList.add(index, frequency);</span>
<span class="nc" id="L638">                    index++;</span>
                }
            }
        }
<span class="nc" id="L642">    }</span>


    /**
     * Returns an array of beta values such that beta &gt; 0 and &lt;= 100.
     *
     * @return an array of valid beta values.
     */
    public static double[] getBetaArray(){
<span class="fc" id="L651">        double dt = 0.01;</span>
<span class="fc" id="L652">        double beta = 0.01;</span>
<span class="fc" id="L653">        double maxBetaValue = 100.0;</span>
<span class="fc" id="L654">        double[] betaArray = new double[(int) (maxBetaValue / 0.01)];</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">        for(int index = 0; index &lt; (int) (maxBetaValue / 0.01); index++){</span>
<span class="fc" id="L656">            betaArray[index] = beta;</span>
<span class="fc" id="L657">            beta += dt;</span>
        }
<span class="fc" id="L659">        return betaArray;</span>
    }

    public static void printWave(SoundWave wave) {
<span class="nc" id="L663">        System.out.print(&quot;Left Channel: &quot;);</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">        for (int i = 0; i &lt; wave.getLeftChannel().length; i++) {</span>
<span class="nc" id="L665">            System.out.print(wave.getLeftChannel()[i] + &quot; &quot;);</span>
        }
<span class="nc" id="L667">        System.out.println();</span>
<span class="nc" id="L668">        System.out.print(&quot;Right Channel: &quot;);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">        for (int i = 0; i &lt; wave.getRightChannel().length; i++) {</span>
<span class="nc" id="L670">            System.out.print(wave.getRightChannel()[i] + &quot; &quot;);</span>
        }
<span class="nc" id="L672">        System.out.println();</span>
<span class="nc" id="L673">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>